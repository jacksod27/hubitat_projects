/*
 * Midea Smart Absolute Humidity Control
 *
 * Version with:
 * - 24-26C setpoint logic based on outdoor temp
 * - Polls humidity every 30min
 * - Max 1.5hr run time, then 30min cooldown
 * - Restart if humidity >60% after cooldown
 * - Utilises Absolute Humidity to determine dry mode over night
 * - Can operate silently over night
 */

definition(
    name: "Midea Smart Absolute Humidity Control",
    namespace: "custom.midea",
    author: "Jacksod27 + Perplexity",
    description: "Smart humidity control for Midea AC with temp setpoint, timers",
    category: "Climate Control",
    iconUrl: "",
    iconX2Url: ""
)

preferences {
    page(name: "mainPage")
}

def mainPage() {
    dynamicPage(name: "mainPage", title: "Midea Smart Dry Mode Humidity Controller", install: true, uninstall: true) {
        section("Sensors") {
            input "humiditySensor", "capability.relativeHumidityMeasurement",
                title: "Humidity sensor", required: true
            input "outdoorTempSensor", "capability.temperatureMeasurement",
                title: "Outdoor temperature sensor (Celsius)", required: true
            input "indoorTempSensor", "capability.temperatureMeasurement", 
                title: "Indoor temperature sensor", required: true
        }
        section("Midea AC units") {
            input "mideaUnits", "capability.thermostat",
                title: "Midea AC devices", required: true, multiple: true
        }
        section("Setpoints & Thresholds") {
            input "highHumTrigger", "number", title: "Start Dry if humidity > (%)", 
                defaultValue: 59, required: true
            input "lowHumStop", "number", title: "Stop Dry if humidity < (%)", 
                defaultValue: 55, required: true
            input "restartHum", "number", title: "Restart after cooldown if > (%)", 
                defaultValue: 50, required: true
            input "minTemp", "number", title: "Min setpoint (C)", 
                defaultValue: 24, required: true
            input "maxTemp", "number", title: "Max setpoint (C)", 
                defaultValue: 26, required: true
        }
        section("Timers") {
            input "pollInterval", "number", title: "Poll humidity every (minutes)", 
                defaultValue: 30, required: true
            input "maxRunTime", "number", title: "Max run time (minutes)", 
                defaultValue: 90, required: true  // 1.5hrs
            input "cooldownTime", "number", title: "Cooldown time (minutes)", 
                defaultValue: 30, required: true
        }
        section("Restore Mode") {
            input "restoreMode", "enum", title: "Restore mode after Dry",
                required: true, defaultValue: "auto",
                options: ["off","auto","cool","heat","fan","dry"]
        }
        section("bedTime") {
            input "bedTime", "time", title: "Bedtime (for quiet mode)"
        }
      
        section("Options") {
            input "enableLogging", "bool", title: "Enable debug logging", 
                defaultValue: true
            input "useQuietNightMode", "bool", title: "Enable Silent Night Mode (1% fan, hourly sleep ramp)", 
                default: false
        }
    }
}

def installed() {
    logDebug "Installed"
    initialize()
}

def updated() {
    logDebug "Updated"
    unsubscribe()
    unschedule()
    initialize()
}

def initialize() {
    state.dryActive = false
    state.sessionStart = null
    state.inCooldown = false
    state.currentSetpoint = null
    state.fanMode = "auto"  // Define missing vars

    subscribe(humiditySensor, "humidity", humidityHandler)
    subscribe(indoorTempSensor, "temperature", humidityHandler)  // Add this
    subscribe(outdoorTempSensor, "temperature", tempHandler)

    unschedule()
    runIn(1800, repeatedPollHumidity)
    runIn(60, timerCheck)
    
    if (useQuietNightMode) {
        runEvery1Hour(hourlySleepAdjust)  // Better than cron
    }
    // Fix bedtime: schedule daily at bedTime (parse properly)
    if (bedTime) {
        def cron = "0 ${bedTime.split(':')[1]} ${bedTime.split(':')[0]} * * ?"  // e.g., "0 0 22 * * ?"
        schedule(cron, enableBedtimeMode)
    }
    logDebug "Initialized"
}

def repeatedPollHumidity() {
    pollHumidity()
    runIn((pollInterval * 60), repeatedPollHumidity)  // Chain next poll
}



def pollHumidity() {
    logDebug "=== 30min POLL ==="
    humiditySensor.refresh()
    runIn(30, humidityHandler)  // Check 30sec after refresh
}


def humidityHandler(evt) {
    if (state.inCooldown) return
    def hum = (humiditySensor.currentValue("humidity") ?: 0) as Integer
    def roomT = indoorTempSensor.currentValue("temperature") ?: 25
    def ah = calcAH(roomT, hum)
    logDebug "RH: ${hum}%, AH: ${ah}g/m³"

    if (!state.dryActive && (hum > highHumTrigger || ah > 12)) {  // RH OR AH
        startDrySession()
    } else if (state.dryActive && hum < lowHumStop && ah < 9) {  // Both low
        endDrySession()
    }
}

def tempHandler(evt) {
    if (state.dryActive) {
        updateSetpoint()
    }
}

def enableBedtimeMode() {
    state.isBedtime = true
    logDebug "Bedtime mode enabled"
}

def startDrySession() {
    logInfo "Starting Dry session"
    state.dryActive = true
    state.sessionStart = now()
    state.inCooldown = false

    mideaUnits.each { dev ->
        dev.setThermostatMode("dry")
        dev.on()
        updateSetpoint(dev)
        dev.setThermostatFanMode(state.fanMode ?: "auto")
        logDebug "Configured ${dev.displayName}"
        
        if (useQuietNightMode && isBedtimeNow()) {  // Define helper
            dev.setThermostatFanMode("silent")  // Assuming Midea supports; check driver [web:7][web:23]
        }
    }
}

def hourlySleepAdjust() {
    if (!state.dryActive || now() < state.bedTime) return  // Night-only
    def roomTemp = indoorTempSensor.currentValue("temperature")
    def target = state.baseSetpoint + (hoursSinceBedtime() * 0.5)  // Ramp +0.5°C/hr
    def ah = calcAH(roomTemp, hum); 
    def targetTemp = state.baseSetpoint + (hoursSinceBedtime() * 0.5); if (ah > 11.5) targetTemp -= 0.5;
    mideaUnits.each { dev ->
        dev.setCoolingSetpoint(target.round())  // Silent if quiet fan
        dev.setThermostatFanMode("silent")  // 1% speed, no beep
    }
    log.info "[MideaSmartDry] Sleep ramp: ${target}°C (room ${roomTemp}°C)"
}


def endDrySession() {
    logInfo "Ending Dry session - humidity low"
    state.dryActive = false
    restoreUnits()
}

def updateSetpoint(dev=null) {
    def outdoorTemp = outdoorTempSensor.currentValue("temperature") ?: 25
    def setpoint = Math.max(minTemp, Math.min(maxTemp, Math.round(outdoorTemp)))
    
    state.currentSetpoint = setpoint
    logDebug "Setpoint: ${setpoint}C (outdoor: ${outdoorTemp}C)"

    if (dev) {
        dev.setCoolingSetpoint(setpoint)  // or setThermostatSetpoint(setpoint)
    } else {
        mideaUnits.each { it.setCoolingSetpoint(setpoint) }
    }
}

def restoreUnits() {
    mideaUnits.each { dev ->
        if (restoreMode == "off") {
            dev.off()
        } else {
            dev.setThermostatMode(restoreMode)
            dev.on()  // Ensure it runs
        }
    }
}

def timerCheck() {
    if (!state.dryActive || !state.sessionStart) {
        runIn(60, timerCheck)  // Fixed: use runIn instead of schedule
        return
    }

    def runMins = (now() - state.sessionStart) / 1000 / 60
    if (runMins >= (maxRunTime as Integer)) {
        logInfo "Max run time reached (${runMins}min)"
        forceEndDry()
    } else {
        runIn(60, timerCheck)  // Check again in 1 minute
    }
}

def forceEndDry() {
    state.dryActive = false
    restoreUnits()
    state.inCooldown = true
    runIn((cooldownTime * 60), cooldownEnd)
}

def cooldownEnd() {
    state.inCooldown = false
    def hum = humiditySensor.currentValue("humidity") ?: 0
    def roomT = indoorTempSensor.currentValue("temperature") ?: 25
    def ah = calcAH(roomT, hum)
    if (hum > restartHum || ah > 11) {
        logInfo "Cooldown end - RH ${hum}%/AH ${ah}g, restarting Dry"
        startDrySession()
    } else {
        logInfo "Cooldown end - OK, continue monitoring"
    }
}

def calcAH(T, RH) {  
    def es = 6.112 * Math.exp((17.67 * T) / (T + 243.5))  
    def e = es * (RH / 100)  
    return (e * 100 * 2.16679) / (T + 273.15)  
}  
// Use: if (calcAH(indoorTemp, humidity) > 11) startDrySession()  

def hoursSinceBedtime() {
    if (!bedTime) return 0
    def nowTime = new Date()
    def bedToday = timeTodayAfter(bedTime, location.timeZone)  // Correct args [web:27]
    def elapsed = nowTime.time - bedToday.time
    return elapsed > 0 ? elapsed / (1000*60*60) : 0  // Avoid negative
}


private boolean isBedtimeNow() {
    if (!bedTime) return false
    def nowTime = new Date()
    def bedToday = timeTodayAfter(bedTime, location.timeZone)
    return nowTime.time >= bedToday.time  // Current bedtime or after
}

private logDebug(msg) { if (enableLogging) log.debug "[MideaSmartDry] ${msg}" }
private logInfo(msg) { log.info "[MideaSmartDry] ${msg}" }















